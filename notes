Igamepluginserveice interface. (implementeres mange af det samme interface)?
Core modul er den der tegner java FX. De andre skal bare kende til entyterne
Forksellige "common" for ikke at have et stort globalt interface.
Ideen med Component basered er at have løs kopling, så man undgår fejl som i monilitisk system


HVORFOR BRUGES JPMS?
- Man kan skabe software vha. 3parts udviklere, uden at være bange for splitpackages
- Brugte 13 år, da det var essensielt, at helloworld nu fylder få kb hvor det før var 1gb.

DEPENDENCY INJECTION vs. CLASSLOADER?
- Servicelocater = har et register
    Interface er polymorfisk

SPRING: Bruger både Servicelocater og dependency injection.
Module info core: require spring.core + context og beans
ind i POM.xml
opens javafx.graphics,spring.core
Instanstiere objectgraf med xml
- properties - spring version
spring på mods.mvn -> includeartifact for at kopier over.

Clean architecture: Ved brug af bean begynder forretningsmodel at afhænge af noget længere ude (spring aware interfaces)

IoC: Inversion of control
Setter injection kan ændres løbende - Contructor injection er statisk.

Collision: Har køretid på n^2, som ikke er holdbar i længden.
Den tjekker alle entities på mappet, hvilket måske ikke er nødvendigt.

MICROSERVICE:
- lab = spring scorecalculator.
- Lav modul? eller indsæt mappen og lav det om til modul?

Nu er den inde i AsteroidFX, så kan man åbne i nyt vindue? Men jeg kan skrive at det virker nu (forbindelsen ihvertfald).


- forskel på komponentbaseret og microsevice er bla. at microservice virker igennem api/over web/cloud.
Hver service har sin egen database (decentraliceret).




Ide:
2 asteriod der collider skifter retning.
Hitpoint for entities



-- Branch: junitTest:
Pom.xml: junit version til parent Pom.xml, så man bare skal skrive junit dependencies, i child Pom.xml, og version står i parent.
2 test, 1 for collides, og 1 for ikke collides.

-- Branch: spring_branch

-- to do:
- Open/close principle?



